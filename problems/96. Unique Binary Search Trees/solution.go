package solution

// 解法一：
// 动态规划
// 对于序列 1 ... n，为了构建所有可能的二叉搜索树，可以遍历每个数字 i，以数字 i 作为根节点，建立二叉搜索树。
// 那么，1 ... i-1 将成为左子树，i+1 ... n 将成为右子树。
// 然后就是递归的建立二叉搜索树。
// 定义：
// G(n) 长度为 n 的序列的不同二叉搜索树个数
// F(i, n) 以 i 为根的不同二叉搜索树个数 1 <= i <= n
// 那么
// G(n) = sum(F(i, n)), 1 <= i <= n
// G(0) = 1, G(1) = 1
// 以 i 为根的不同二叉搜索树个数的计算，也可以分解为 G 的计算，只需要计算左子树的不同二叉搜索树个数和右子树的不同二叉搜索树个数
// 两者相乘就可以，所以
// F(i, n) = G(i-1) * G(n-i)
// 因为 G(n) 只和序列的长度有关系，和内容谷关，所以 G(i+1 ... n) = G(1 ... n-i)
// 综上
// G(n) = sum(G(i-1) * G(n-i))
//      = G(0) * G(n-1) + G(1) * G(n-2) + ... + G(n-1) * G(0)
func numTrees(n int) int {
	g := make([]int, n+1)
	g[0] = 1
	g[1] = 1
	for i := 2; i <= n; i++ {
		for j := 1; j <= i; j++ {
			g[i] += g[j-1] * g[i-j]
		}
	}
	return g[n]
}
